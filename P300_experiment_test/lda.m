function [w, classes, y1, y2, test_y, center] = lda(train_features, group, test_features)
% lda - выполняет линейный дискриминантный анализ
% Input:
%
%	train_features - обучающая выборка (матрица m * n, где n - количество измерений (замеров)
%   m-мерного вектора признаков), класс каждого из n замеров вектора
%   заранее определен группирующей переменной
%	вектор признаков - m точек -> m-мерное пространство признаков,
%	содержащее n m-мерных точек (n измерений (замеров) вектора)
%	линейный дискриминантный анализ - метод уменьшения размерностей
%	для того, чтобы эффективно разделить классы необходимо точки m-мерного
%	пространства спроецировать в одномерное пространство:
%	необходимо найти y = w' * x - линию, на которую будут спроецированы все многомерные точки
%	Пример:
%	n/2 точек в 1-мерном пространстве - класс "p300"
%	n/2 точек в 1-мерном пространстве - класс "no_p300"
%
%	group - группирующая переменная 
%	Пример: 1 - класс "p300", 0 - класс "no_p300"
%
%	test_features - тестовая выборка
%   (матрица m * n (n измерений (замеров) m-мерного вектора признаков),
%	класс заранее не определен
%
% Output:
%	classes (таблица n * 1) таблица, определяющая принадлежность к тому
%   или иному классу каждого из n векторов тестовой выборки
%	Пример: 1 - класс "p300", 0 - класс "no_p300"
%
%	y1 - проекция первого класса на вектор w (group == 1)
%
%	y2 - проекция второго класса на вектор w (group == 0)
%
%	test_y - проекция тестовой выборки на вектор w
%
%	center - порог классификации

%% Train
% train_features m * n (n замеров m-мерного вектора признаков)
c1 = find(group == 1); 
c2 = find(group == 0);
train_c1 = train_features(:, c1);
train_c2 = train_features(:, c2);

% classes means
mean1 = mean(train_c1, 2); % одна 192-мерная точка (среднее n точек класса 1)
mean2 = mean(train_c2, 2); % одна 192-мерная точка (среднее n точек класса 2)
% ковариационная матрица 192x192 для 192-мерной величины
S1 = cov(train_c1');
S2 = cov(train_c2');

% within-class scatter matrix  (внутриклассовая матрица разброса)
Sw = S1 + S2;

% between-class scatter matrix (межклассовая матрица разброса)
Sb = (mean1 - mean2) * (mean1 - mean2)';

% вычисление вектора w (y = w' * x)
% w = inv(Sw)*(mean1 - mean2);
% w = Sw \ (mean1 - mean2);
w = pinv(Sw) * (mean1 - mean2); 

% замена вычисления обратной матрицы на вычисление псевдообратной матрицы
% (для случаев, когда расчет обратной матрицы не возможен)

% проекции двух классов на вектор w
y1 = w' * train_c1;
y2 = w' * train_c2;

% определение порога
m1 = mean(y1);
m2 = mean(y2);
cp = abs( (m1 - m2)/2 );
if (m1 < m2)
    center = m1 + cp;
    work = 1;
    belowthres = 1;
    afterthres = 0;
elseif (m1 == m2)
    center = m1;
    work = 0;
elseif (m1 > m2)
    center = m2 + cp;
    work = 1;
    belowthres = 0;
    afterthres = 1;
end

%% Classification (классификация тестовой выборки)
%  вычислении проекции точек тестовой выборки на вектор w
test_y = w' * test_features;
class1 = find(test_y > center); 
class2 = find(test_y < center);
class0 = find(test_y == center);

% вектор результатов классификации тестовой выборки
classes = zeros(1, size(test_features, 2));

if (work == 1) %  разделение классов возможно
    classes(1, class1) = afterthres;
    classes(1, class2) = belowthres;
    classes(1, class0) = 100;
elseif (work == 0) % разделение классов затруднено (средние совпадают)
    classes(:, :) = 100;
end

end